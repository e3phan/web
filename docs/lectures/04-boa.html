<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Branches and Binary Operators</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CSE 131</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
		<a href="../calendar.html">Calendar</a>
                <a href="../grades.html">Grades</a>
                <a href="../assignments.html">Assignments</a>
                <a href="../lectures.html">Lectures</a>
                <a href="../resources.html">Resources</a>
            </div>
        </div>

        <div id="content">
            <h1>Branches and Binary Operators</h1>

            <h2 id="boa-branches-and-binary-operators">BOA: Branches and Binary Operators</h2>
<p>Next, lets add</p>
<ul>
<li>Branches (<code>if</code>-expressions)</li>
<li>Binary Operators (<code>+</code>, <code>-</code>, etc.)</li>
</ul>
<p>In the process of doing so, we will learn about</p>
<ul>
<li><strong>Intermediate Forms</strong></li>
<li><strong>Normalization</strong></li>
</ul>
<h2 id="branches">Branches</h2>
<p>Lets start first with branches (conditionals).</p>
<p>We will stick to our recipe of:</p>
<ol type="1">
<li>Build intuition with <strong>examples</strong>,</li>
<li>Model problem with <strong>types</strong>,</li>
<li>Implement with <strong>type-transforming-functions</strong>,</li>
<li>Validate with <strong>tests</strong>.</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">ENum</span>                  <span class="co">-- 12 </span></a>
<a class="sourceLine" id="cb1-2" title="2">          <span class="fu">|</span> <span class="dt">EPrim1</span> <span class="dt">Op1</span>  <span class="dt">Expr</span>      <span class="co">-- add1(e)</span></a>
<a class="sourceLine" id="cb1-3" title="3">          <span class="fu">|</span> <span class="dt">EVar</span>   <span class="dt">Id</span>             <span class="co">-- x</span></a>
<a class="sourceLine" id="cb1-4" title="4">          <span class="fu">|</span> <span class="dt">ELet</span>   <span class="dt">Id</span>   <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="co">-- let x = e1 in e2</span></a>
<a class="sourceLine" id="cb1-5" title="5">          <span class="fu">|</span> <span class="dt">EIf</span>    <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a></code></pre></div>
<h3 id="examples">Examples</h3>
<p>First, lets look at some examples of what we mean by branches.</p>
<ul>
<li>For now, lets treat <code>0</code> as “false” and non-zero as “true”</li>
</ul>
<h3 id="example-if1">Example: <code>If1</code></h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">if</span> <span class="dv">10</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="dv">22</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">else</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb2-4" title="4">  sub1(<span class="dv">0</span>)</a></code></pre></div>
<ul>
<li>Since <code>10</code> is <em>not</em> <code>0</code> we evaluate the “then” case to get <code>22</code></li>
</ul>
<h3 id="example-if2">Example: <code>If2</code></h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">if</span> sub(<span class="dv">1</span>)<span class="fu">:</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dv">22</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">else</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb3-4" title="4">  sub1(<span class="dv">0</span>)</a></code></pre></div>
<ul>
<li>Since <code>sub(1)</code> <em>is</em> <code>0</code> we evaluate the “else” case to get <code>-1</code></li>
</ul>
<h3 id="quiz-if3">QUIZ: <code>If3</code></h3>
<p><code>if-else</code> is also an <em>expression</em> so we can nest them:</p>
<p>What should the following evaluate to?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">let</span> x <span class="fu">=</span> <span class="kw">if</span> sub(<span class="dv">1</span>)<span class="fu">:</span></a>
<a class="sourceLine" id="cb4-2" title="2">          <span class="dv">22</span></a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="kw">else</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb4-4" title="4">          sub1(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">in</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">if</span> x<span class="fu">:</span></a>
<a class="sourceLine" id="cb4-7" title="7">    add1(x)</a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="kw">else</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="dv">999</span></a></code></pre></div>
<ul>
<li><strong>A.</strong> <code>999</code></li>
<li><strong>B.</strong> <code>0</code></li>
<li><strong>C.</strong> <code>1</code></li>
<li><strong>D.</strong> <code>1000</code></li>
<li><strong>E.</strong> <code>-1</code></li>
</ul>
<!-- 
  * `x` is bound to `-1`...
  * ... which is _non-zero_ so we evaluate `add1(x)` yielding `0`
-->
<h3 id="control-flow-in-assembly">Control Flow in Assembly</h3>
<p>To compile branches, we will use:</p>
<ul>
<li><strong>labels</strong> of the form</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">our_code_label:</span></a>
<a class="sourceLine" id="cb5-2" title="2">  ...</a></code></pre></div>
<p>are <em>“landmarks”</em> from which execution (control-flow) can be started, or to which it can be diverted,</p>
<ul>
<li><strong>comparisons</strong> of the form</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb6-1" title="1"><span class="bu">cmp</span> a1, a2</a></code></pre></div>
<ul>
<li>Perform a (numeric) <strong>comparison</strong> between the values <code>a1</code> and <code>a2</code>, and</li>
<li><p>Store the result in a special <strong>processor flag</strong>,</p></li>
<li><p><strong>Jump</strong> operations of the form</p></li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb7-1" title="1"><span class="bu">jmp</span> <span class="pp">LABEL</span>     # jump unconditionally (i.e. always)</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="bu">je</span>  <span class="pp">LABEL</span>     # jump <span class="pp">if</span> previous comparison result was EQUAL  </a>
<a class="sourceLine" id="cb7-3" title="3"><span class="bu">jne</span> <span class="pp">LABEL</span>     # jump <span class="pp">if</span> previous comparison result was <span class="bu">NOT</span>-EQUAL  </a></code></pre></div>
<ul>
<li>Use the result of the <strong>flag</strong> set by the most recent <code>cmp</code></li>
<li>To <em>continue execution</em> from the given <code>LABEL</code></li>
</ul>
<h3 id="quiz">QUIZ</h3>
<p>Which of the following is a valid x86 encoding of</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="cf">if</span> <span class="dv">10</span>:</a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="dv">22</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="cf">else</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="dv">33</span></a></code></pre></div>
<figure>
<img src="../static/img/quiz-if-asm.png" alt="QUIZ: Compiling if-else" /><figcaption>QUIZ: Compiling if-else</figcaption>
</figure>
<h3 id="strategy">Strategy</h3>
<p>To compile an expression of the form</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">if</span> eCond<span class="fu">:</span></a>
<a class="sourceLine" id="cb9-2" title="2">  eThen</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">else</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb9-4" title="4">  eElse</a></code></pre></div>
<p>We will:</p>
<ol type="1">
<li>Compile <code>eCond</code></li>
<li>Compare the result (in <code>eax</code>) against <code>0</code></li>
<li>Jump if the result <em>is zero</em> to a <strong>special</strong> <code>&quot;IfFalse&quot;</code> label
<ul>
<li>At which we will evaluate <code>eElse</code>,</li>
<li>Ending with a special <code>&quot;IfExit&quot;</code> label.</li>
</ul></li>
<li>(Otherwise) continue to evaluate <code>eTrue</code>
<ul>
<li>And then jump (unconditionally) to the <code>&quot;IfExit&quot;</code> label.</li>
</ul></li>
</ol>
<h3 id="example-if-expressions-to-asm">Example: If-Expressions to <code>Asm</code></h3>
<p>Lets see how our strategy works by example:</p>
<h3 id="example-if1-1">Example: if1</h3>
<figure>
<img src="../static/img/if-1-to-asm.png" alt="Example: if1" /><figcaption>Example: if1</figcaption>
</figure>
<h3 id="example-if2-1">Example: if2</h3>
<figure>
<img src="../static/img/if-2-to-asm.png" alt="Example: if2" /><figcaption>Example: if2</figcaption>
</figure>
<h3 id="example-if3">Example: if3</h3>
<figure>
<img src="../static/img/if-3-to-asm.png" alt="Example: if3" /><figcaption>Example: if3</figcaption>
</figure>
<p>Oops, <strong>cannot reuse labels</strong> across if-expressions!</p>
<ul>
<li>Can’t use same label in two places (invalid assembly)</li>
</ul>
<figure>
<img src="../static/img/if-3-to-asm-bad.png" alt="Example: if3 wrong" /><figcaption>Example: if3 wrong</figcaption>
</figure>
<p>Oops, need <strong>distinct labels</strong> for each branch!</p>
<ul>
<li>Require <strong>distinct tags</strong> for each <code>if-else</code> expression</li>
</ul>
<figure>
<img src="../static/img/if-3-to-asm-tag.png" alt="Example: if3 tagged" /><figcaption>Example: if3 tagged</figcaption>
</figure>
<h3 id="types-source">Types: Source</h3>
<p>Lets modify the <em>Source Expression</em></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="fu">=</span> <span class="dt">Number</span> <span class="dt">Int</span>                        a</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="fu">|</span> <span class="dt">Add1</span>   (<span class="dt">Expr</span> a)                   a</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="fu">|</span> <span class="dt">Sub1</span>   (<span class="dt">Expr</span> a)                   a</a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="fu">|</span> <span class="dt">Let</span>    <span class="dt">Id</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)       a</a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="fu">|</span> <span class="dt">Var</span>    <span class="dt">Id</span>                         a</a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="fu">|</span> <span class="dt">If</span>     (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a) a</a></code></pre></div>
<ul>
<li>Add <code>if-else</code> expressions and</li>
<li>Add <strong>tags</strong> of type <code>a</code> for each sub-expression
<ul>
<li>Tags are polymorphic <code>a</code> so we can have <em>different types</em> of tags</li>
<li>e.g. Source-Position information for error messages</li>
</ul></li>
</ul>
<p>Lets define a name for <code>Tag</code> (just integers).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">type</span> <span class="dt">Tag</span>   <span class="fu">=</span> <span class="dt">Int</span></a></code></pre></div>
<p>We will now use:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">type</span> <span class="dt">BareE</span> <span class="fu">=</span> <span class="dt">Expr</span> ()     <span class="co">-- AST after parsing</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">type</span> <span class="dt">TagE</span>  <span class="fu">=</span> <span class="dt">Expr</span> <span class="dt">Tag</span>    <span class="co">-- AST with distinct tags</span></a></code></pre></div>
<h3 id="types-assembly">Types: Assembly</h3>
<p>Now, lets extend the <em>Assembly</em> with labels, comparisons and jumps:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">data</span> <span class="dt">Label</span></a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="fu">=</span> <span class="dt">BranchFalse</span> <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="fu">|</span> <span class="dt">BranchExit</span>  <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="kw">data</span> <span class="dt">Instruction</span></a>
<a class="sourceLine" id="cb13-6" title="6">  <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb13-7" title="7">  <span class="fu">|</span> <span class="dt">ICmp</span>   <span class="dt">Arg</span>   <span class="dt">Arg</span>  <span class="co">-- Compare two arguments</span></a>
<a class="sourceLine" id="cb13-8" title="8">  <span class="fu">|</span> <span class="dt">ILabel</span> <span class="dt">Label</span>      <span class="co">-- Create a label</span></a>
<a class="sourceLine" id="cb13-9" title="9">  <span class="fu">|</span> <span class="dt">IJmp</span>   <span class="dt">Label</span>      <span class="co">-- Jump always</span></a>
<a class="sourceLine" id="cb13-10" title="10">  <span class="fu">|</span> <span class="dt">IJe</span>    <span class="dt">Label</span>      <span class="co">-- Jump if equal  </span></a>
<a class="sourceLine" id="cb13-11" title="11">  <span class="fu">|</span> <span class="dt">IJne</span>   <span class="dt">Label</span>      <span class="co">-- Jump if not-equal</span></a></code></pre></div>
<h3 id="transforms">Transforms</h3>
<p>We can’t expect <em>programmer</em> to put in tags (yuck.)</p>
<ul>
<li>Lets squeeze in a <code>tagging</code> transform into our pipeline</li>
</ul>
<figure>
<img src="../static/img/compiler-pipeline-tag.png" alt="Adding Tagging to the Compiler Pipeline" /><figcaption>Adding Tagging to the Compiler Pipeline</figcaption>
</figure>
<h3 id="transforms-parse">Transforms: Parse</h3>
<p>Just as before, but now puts a dummy <code>()</code> into each position</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">λ<span class="fu">&gt;</span> <span class="kw">let</span> parseStr s <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">const</span> ()) (parse <span class="st">&quot;&quot;</span> s)</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3">λ<span class="fu">&gt;</span> <span class="kw">let</span> e <span class="fu">=</span> parseStr <span class="st">&quot;if 1: 22 else: 33&quot;</span></a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5">λ<span class="fu">&gt;</span> e</a>
<a class="sourceLine" id="cb14-6" title="6"><span class="dt">If</span> (<span class="dt">Number</span> <span class="dv">1</span> ()) (<span class="dt">Number</span> <span class="dv">22</span> ()) (<span class="dt">Number</span> <span class="dv">33</span> ()) ()</a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8">λ<span class="fu">&gt;</span> label e</a>
<a class="sourceLine" id="cb14-9" title="9"><span class="dt">If</span> (<span class="dt">Number</span> <span class="dv">1</span> ((),<span class="dv">0</span>)) (<span class="dt">Number</span> <span class="dv">22</span> ((),<span class="dv">1</span>)) (<span class="dt">Number</span> <span class="dv">33</span> ((),<span class="dv">2</span>)) ((),<span class="dv">3</span>)</a></code></pre></div>
<h3 id="transforms-tag">Transforms: Tag</h3>
<p>The key work is done by <code>doTag i e</code></p>
<ol type="1">
<li>Recursively walk over the <code>BareE</code> named <code>e</code> starting tagging at counter <code>i</code></li>
<li>Return a pair <code>(i', e')</code> of <em>updated counter</em> <code>i'</code> and tagged expr <code>e'</code></li>
</ol>
<p><strong>QUIZ</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">doTag ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BareE</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">TagE</span>)</a>
<a class="sourceLine" id="cb15-2" title="2">doTag i (<span class="dt">Number</span> n _)    <span class="fu">=</span> (i <span class="fu">+</span> <span class="dv">1</span> , <span class="dt">Number</span> n i)</a>
<a class="sourceLine" id="cb15-3" title="3">doTag i (<span class="dt">Var</span>    x _)    <span class="fu">=</span> (i <span class="fu">+</span> <span class="dv">1</span> , <span class="dt">Var</span>     x i)</a>
<a class="sourceLine" id="cb15-4" title="4">doTag i (<span class="dt">Let</span> x e1 e2 _) <span class="fu">=</span> (_2    , <span class="dt">Let</span> x e1' e2' i2)</a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-6" title="6">    (i1, e1')           <span class="fu">=</span> doTag i  e1</a>
<a class="sourceLine" id="cb15-7" title="7">    (i2, e2')           <span class="fu">=</span> doTag _1 e2</a></code></pre></div>
<p>What expressions shall we fill in for <code>_1</code> and <code>_2</code> ?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="co">{- A -}</span>   _1 <span class="fu">=</span> i</a>
<a class="sourceLine" id="cb16-2" title="2">          _2 <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co">{- B -}</span>   _1 <span class="fu">=</span> i</a>
<a class="sourceLine" id="cb16-5" title="5">          _2 <span class="fu">=</span> i1 <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-6" title="6"></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="co">{- C -}</span>   _1 <span class="fu">=</span> i</a>
<a class="sourceLine" id="cb16-8" title="8">          _2 <span class="fu">=</span> i2 <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="co">{- D -}</span>   _1 <span class="fu">=</span> i1</a>
<a class="sourceLine" id="cb16-11" title="11">          _2 <span class="fu">=</span> i2 <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-12" title="12"></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="co">{- E -}</span>   _1 <span class="fu">=</span> i2</a>
<a class="sourceLine" id="cb16-14" title="14">          _2 <span class="fu">=</span> i1 <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<!--

We can now fill in the complete version:


```haskell
doTag :: Int -> BareE -> (Int, TagE)

doTag i (Number n _)    = (i + 1 , Number n i)

doTag i (Var    x _)    = (i + 1 , Var     x i)

doTag i (Let x e1 e2 _) = (i2 + 1, Let x e1' e2' i2)
  where
    (i1, e1')           = doTag i  e1
    (i2, e2')           = doTag i1 e2

doTag i (If e1 e2 e3 _) = (i3 + 1, If e1' e2' e3' i3)
  where
    (i1, e1')           = doTag i  e1
    (i2, e2')           = doTag i1 e2
    (i3, e3')           = doTag i2 e3
```

-->
<p>(<strong>ProTip:</strong> Use <code>mapAccumL</code>)</p>
<p>We can now tag the whole program by</p>
<ul>
<li><p>Calling <code>doTag</code> with the initial counter (e.g. <code>0</code>),</p></li>
<li><p>Throwing away the final counter.</p></li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">tag ::</span> <span class="dt">BareE</span> <span class="ot">-&gt;</span> <span class="dt">TagE</span></a>
<a class="sourceLine" id="cb17-2" title="2">tag e <span class="fu">=</span> e'  <span class="kw">where</span>  (_, e') <span class="fu">=</span> doTag <span class="dv">0</span> e</a></code></pre></div>
<h3 id="transforms-codegen">Transforms: CodeGen</h3>
<p>Now that we have the tags we lets implement our <a href="#strategy">compilation strategy</a></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">compile env (<span class="dt">If</span> eCond eTrue eFalse i)</a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="fu">=</span>   compile env eCond <span class="fu">++</span>              <span class="co">-- compile `eCond`</span></a>
<a class="sourceLine" id="cb18-3" title="3">    [ <span class="dt">ICmp</span> (<span class="dt">Reg</span> <span class="dt">EAX</span>) (<span class="dt">Const</span> <span class="dv">0</span>)          <span class="co">-- compare result to 0</span></a>
<a class="sourceLine" id="cb18-4" title="4">    , <span class="dt">IJe</span> (<span class="dt">BranchFalse</span> i)               <span class="co">-- if-zero then jump to 'False'-block</span></a>
<a class="sourceLine" id="cb18-5" title="5">    ]</a>
<a class="sourceLine" id="cb18-6" title="6">   <span class="fu">++</span> compile env eTrue  <span class="fu">++</span>             <span class="co">-- code for `True`-block</span></a>
<a class="sourceLine" id="cb18-7" title="7">    [ <span class="dt">IJmp</span>   lExit      ]               <span class="co">-- jump to exit (don't execute `False`-block!)</span></a>
<a class="sourceLine" id="cb18-8" title="8">   <span class="fu">++</span></a>
<a class="sourceLine" id="cb18-9" title="9">      <span class="dt">ILabel</span> (<span class="dt">BranchFalse</span> i)            <span class="co">-- start of `False`-block</span></a>
<a class="sourceLine" id="cb18-10" title="10">   <span class="fu">:</span> compile env eFalse <span class="fu">++</span>              <span class="co">-- code for `False`-block</span></a>
<a class="sourceLine" id="cb18-11" title="11">    [ <span class="dt">ILabel</span> (<span class="dt">BranchExit</span> i) ]           <span class="co">-- exit</span></a></code></pre></div>
<h3 id="recap-branches">Recap: Branches</h3>
<ul>
<li><code>Tag</code> each sub-expression,</li>
<li>Use tag to generate control-flow labels implementing branch.</li>
</ul>
<p><strong>Lesson:</strong> Tagged program representation simplifies compilation…</p>
<ul>
<li>Next: another example of how intermediate representations help.</li>
</ul>
<h2 id="binary-operations">Binary Operations</h2>
<p>You know the drill.</p>
<ol type="1">
<li>Build intuition with <strong>examples</strong>,</li>
<li>Model problem with <strong>types</strong>,</li>
<li>Implement with <strong>type-transforming-functions</strong>,</li>
<li>Validate with <strong>tests</strong>.</li>
</ol>
<h3 id="compiling-binary-operations">Compiling Binary Operations</h3>
<p>Lets look at some expressions and figure out how they would get compiled.</p>
<ul>
<li>Recall: We want the result to be in <code>eax</code> after the instructions finish.</li>
</ul>
<h4 id="quiz-1">QUIZ</h4>
<p>What is the assembly corresponding to <code>33 - 10</code> ?</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode nasm"><code class="sourceCode nasm"><a class="sourceLine" id="cb19-1" title="1">?<span class="dv">1</span> <span class="kw">eax</span>, ?<span class="dv">2</span></a>
<a class="sourceLine" id="cb19-2" title="2">?<span class="dv">3</span> <span class="kw">eax</span>, ?<span class="dv">4</span></a>
<a class="sourceLine" id="cb19-3" title="3"></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="kw">mov</span> <span class="kw">eax</span>, <span class="dv">33</span></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="kw">sub</span> <span class="kw">eax</span>, <span class="dv">10</span></a></code></pre></div>
<ul>
<li><p><strong>A.</strong> <code>?1 = sub</code>, <code>?2 = 33</code>, <code>?3 = mov</code>, <code>?4 = 10</code></p></li>
<li><p><strong>B.</strong> <code>?1 = mov</code>, <code>?2 = 33</code>, <code>?3 = sub</code>, <code>?4 = 10</code></p></li>
<li><p><strong>C.</strong> <code>?1 = sub</code>, <code>?2 = 10</code>, <code>?3 = mov</code>, <code>?4 = 33</code></p></li>
<li><p><strong>D.</strong> <code>?1 = mov</code>, <code>?2 = 10</code>, <code>?3 = sub</code>, <code>?4 = 33</code></p></li>
</ul>
<p>How to compile <code>n1 * n2</code></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode nasm"><code class="sourceCode nasm"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">mov</span> <span class="kw">eax</span>, n1</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">mul</span> <span class="kw">eax</span>, n2</a></code></pre></div>
<h4 id="example-bin1">Example: Bin1</h4>
<p>Lets start with some easy ones. The source:</p>
<figure>
<img src="../static/img/bin-1-to-asm.png" alt="Example: Bin 1" /><figcaption>Example: Bin 1</figcaption>
</figure>
<p><strong>Strategy:</strong> Given <code>n1 + n2</code></p>
<ul>
<li>Move <code>n1</code> into <code>eax</code>,</li>
<li>Add <code>n2</code> to <code>eax</code>.</li>
</ul>
<h4 id="example-bin2">Example: Bin2</h4>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">10</span>        <span class="co">-- position 1 on stack</span></a>
<a class="sourceLine" id="cb21-2" title="2">  , y <span class="fu">=</span> <span class="dv">20</span>        <span class="co">-- position 2 on stack</span></a>
<a class="sourceLine" id="cb21-3" title="3">  , z <span class="fu">=</span> <span class="dv">30</span>        <span class="co">-- position 3 on stack</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">in</span></a>
<a class="sourceLine" id="cb21-5" title="5">   x <span class="fu">+</span> (y <span class="fu">*</span> z)</a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">let</span> x <span class="fu">=</span> <span class="dv">10</span>        <span class="co">-- position 1 on stack</span></a>
<a class="sourceLine" id="cb22-2" title="2">  , y <span class="fu">=</span> <span class="dv">20</span>        <span class="co">-- position 2 on stack</span></a>
<a class="sourceLine" id="cb22-3" title="3">  , z <span class="fu">=</span> <span class="dv">30</span>        <span class="co">-- position 3 on stack</span></a>
<a class="sourceLine" id="cb22-4" title="4">  , tmp <span class="fu">=</span> y <span class="fu">*</span> z</a>
<a class="sourceLine" id="cb22-5" title="5"><span class="kw">in</span></a>
<a class="sourceLine" id="cb22-6" title="6">   x <span class="fu">+</span> tmp</a></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode nasm"><code class="sourceCode nasm"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">mov</span> <span class="kw">eax</span>, <span class="dv">10</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">mov</span> [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">1</span>], <span class="kw">eax</span>    <span class="co">; put x on stack</span></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="kw">mov</span> <span class="kw">eax</span>, <span class="dv">20</span></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">mov</span> [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">2</span>], <span class="kw">eax</span>    <span class="co">; put y on stack</span></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="kw">mov</span> <span class="kw">eax</span>, <span class="dv">30</span></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="kw">mov</span> [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">3</span>], <span class="kw">eax</span>    <span class="co">; put z on stack</span></a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="kw">mov</span> <span class="kw">eax</span>, [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">2</span>]    <span class="co">; grab y </span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="kw">mul</span> <span class="kw">eax</span>, [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">3</span>]    <span class="co">; mul by z </span></a>
<a class="sourceLine" id="cb23-10" title="10"><span class="kw">mov</span> [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">4</span>], <span class="kw">eax</span>    <span class="co">; put tmp on stack</span></a>
<a class="sourceLine" id="cb23-11" title="11"></a>
<a class="sourceLine" id="cb23-12" title="12"><span class="kw">mov</span> <span class="kw">eax</span>, [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">1</span>]    <span class="co">; grab x</span></a>
<a class="sourceLine" id="cb23-13" title="13"><span class="kw">add</span> <span class="kw">eax</span>, [<span class="kw">ebp</span> - <span class="dv">4</span>*<span class="dv">4</span>]</a></code></pre></div>
<p>What if the first operand is a variable?</p>
<figure>
<img src="../static/img/bin-2-to-asm.png" alt="Example: Bin 2" /><figcaption>Example: Bin 2</figcaption>
</figure>
<p>Simple, just copy the variable off the stack into <code>eax</code></p>
<p><strong>Strategy:</strong> Given <code>x + n</code></p>
<ul>
<li>Move <code>x</code> (from stack) into <code>eax</code>,</li>
<li>Add <code>n</code> to <code>eax</code>.</li>
</ul>
<h4 id="example-bin3">Example: Bin3</h4>
<p>Same thing works if the second operand is a variable.</p>
<figure>
<img src="../static/img/bin-3-to-asm.png" alt="Example: Bin 3" /><figcaption>Example: Bin 3</figcaption>
</figure>
<p>Strategy: Given <code>x + n</code></p>
<ul>
<li>Move <code>x</code> (from stack) into <code>eax</code>,</li>
<li>Add <code>n</code> to <code>eax</code>.</li>
</ul>
<h3 id="quiz-2">QUIZ</h3>
<p>What is the assembly corresponding to <code>(10 + 20) * 30</code> ?</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode nasm"><code class="sourceCode nasm"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">mov</span> <span class="kw">eax</span>, <span class="dv">10</span></a>
<a class="sourceLine" id="cb24-2" title="2">?<span class="dv">1</span>  <span class="kw">eax</span>, ?<span class="dv">2</span></a>
<a class="sourceLine" id="cb24-3" title="3">?<span class="dv">3</span>  <span class="kw">eax</span>, ?<span class="dv">4</span></a></code></pre></div>
<ul>
<li><p><strong>A.</strong> <code>?1 = add</code>, <code>?2 = 30</code>, <code>?3 = mul</code>, <code>?4 = 20</code></p></li>
<li><p><strong>B.</strong> <code>?1 = mul</code>, <code>?2 = 30</code>, <code>?3 = add</code>, <code>?4 = 20</code></p></li>
<li><p><strong>C.</strong> <code>?1 = add</code>, <code>?2 = 20</code>, <code>?3 = mul</code>, <code>?4 = 30</code></p></li>
<li><p><strong>D.</strong> <code>?1 = mul</code>, <code>?2 = 20</code>, <code>?3 = add</code>, <code>?4 = 30</code></p></li>
</ul>
<h3 id="second-operand-is-constant">Second Operand is Constant</h3>
<p>In general, to compile <code>e + n</code> we can do</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">     compile e      </a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="fu">++</span>              <span class="co">-- result of e is in eax</span></a>
<a class="sourceLine" id="cb25-3" title="3">     [add eax, n]</a></code></pre></div>
<h3 id="example-bin4">Example: Bin4</h3>
<p>But what if we have <em>nested</em> expressions</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">*</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span>)</a></code></pre></div>
<ul>
<li>Can compile <code>1 + 2</code> with result in <code>eax</code> …</li>
<li>.. but then need to <em>reuse</em> <code>eax</code> for <code>3 + 4</code></li>
</ul>
<p>Need to <strong>save</strong> <code>1 + 2</code> somewhere!</p>
<p><strong>Idea</strong> How about use <em>another</em> register for <code>3 + 4</code>?</p>
<ul>
<li>But then what about <code>(1 + 2) * (3 + 4) * (5 + 6)</code> ?</li>
<li>In general, may need to <em>save</em> more sub-expressions than we have registers.</li>
</ul>
<h3 id="idea-immediate-expressions">Idea: Immediate Expressions</h3>
<p>Why were <code>1 + 2</code> and <code>x + y</code> so easy to compile but <code>(1 + 2) * (3 + 4)</code> not?</p>
<p>Because <code>1</code> and <code>x</code> are <strong>immediate expressions</strong></p>
<p>Their values don’t require any computation!</p>
<ul>
<li>Either a <strong>constant</strong>, or,</li>
<li><strong>variable</strong> whose value is on the stack.</li>
</ul>
<h3 id="idea-administrative-normal-form-anf">Idea: Administrative Normal Form (ANF)</h3>
<p>An expression is in <strong>Administrative Normal Form (ANF)</strong></p>
<blockquote>
<p>if <strong>all primitive operations</strong> have <strong>immediate</strong> arguments.</p>
</blockquote>
<p><strong>Primitive Operations:</strong> Those whose values we <em>need</em> for computation to proceed.</p>
<ul>
<li><code>v1 + v2</code></li>
<li><code>v1 - v2</code></li>
<li><code>v1 * v2</code></li>
</ul>
<h3 id="quiz-3">QUIZ</h3>
<p>Is the following expression in ANF?</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1">(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">*</span> (<span class="dv">4</span> <span class="fu">-</span> <span class="dv">3</span>)</a></code></pre></div>
<p><strong>A.</strong> Yes, its ANF. <strong>B.</strong> Nope, its not, because of <code>+</code> <strong>C.</strong> Nope, its not, because of <code>*</code> <strong>D.</strong> Nope, its not, because of <code>-</code> <strong>E.</strong> Huh, WTF is ANF?</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">isImm ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb28-2" title="2">isImm (<span class="dt">Number</span> {}) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb28-3" title="3">isImm (<span class="dt">Id</span> {})     <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb28-4" title="4">isImm _           <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb28-5" title="5"></a>
<a class="sourceLine" id="cb28-6" title="6"><span class="ot">isANF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb28-7" title="7">isANF (<span class="dt">Number</span> {})       <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb28-8" title="8">isANF (<span class="dt">Id</span> {})           <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb28-9" title="9">isANF (<span class="dt">Prim1</span> _ e1 _)    <span class="fu">=</span> isANF e1 <span class="co">-- no need to be `isImm e1`!</span></a>
<a class="sourceLine" id="cb28-10" title="10"></a>
<a class="sourceLine" id="cb28-11" title="11">isANF (<span class="dt">Prim2</span> _ e1 e2 _) <span class="fu">=</span> isImm e1 <span class="fu">&amp;&amp;</span> isImm e2</a>
<a class="sourceLine" id="cb28-12" title="12">isANF (<span class="dt">Let</span> _ e1 e2 _)   <span class="fu">=</span> isANF e1 <span class="fu">&amp;&amp;</span> isANF e2</a>
<a class="sourceLine" id="cb28-13" title="13">isANF (<span class="dt">If</span> e1 e2 e3 _)   <span class="fu">=</span> <span class="fu">???</span>   <span class="fu">&amp;&amp;</span> isANF e2 <span class="fu">&amp;&amp;</span> isANF e3</a></code></pre></div>
<p><strong>A.</strong> <em>must be</em> isImm <strong>B.</strong> <em>meh</em> ANF is fine!</p>
<!-- 
### Compound Expressions

Unfortunately, the below is _not_ in ANF

```haskell
(1 + 2) * (3 + 4)
```

* As the `*` has _non-immediate_ arguments.

-->
<h3 id="conversion-to-anf">Conversion to ANF</h3>
<p>However, note the following variant <em>is</em> in ANF</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">let</span> t1 <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb29-2" title="2">  , t2 <span class="fu">=</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">in</span>  </a>
<a class="sourceLine" id="cb29-4" title="4">    t1 <span class="fu">*</span> t2</a></code></pre></div>
<p>How can we compile the above code?</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb30-1" title="1"><span class="co">; TODO in class</span></a></code></pre></div>
<h3 id="binary-operations-strategy">Binary Operations: Strategy</h3>
<p>We can convert <em>any</em> expression to ANF</p>
<ul>
<li>By adding “temporary” variables for sub-expressions</li>
</ul>
<figure>
<img src="../static/img/compiler-pipeline-anf.png" alt="Compiler Pipeline with ANF" /><figcaption>Compiler Pipeline with ANF</figcaption>
</figure>
<ul>
<li><strong>Step 1:</strong> Compiling ANF into Assembly</li>
<li><strong>Step 2:</strong> Converting Expressions into ANF</li>
</ul>
<h3 id="types-source-1">Types: Source</h3>
<p>Lets add binary primitive operators</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">data</span> <span class="dt">Prim2</span></a>
<a class="sourceLine" id="cb31-2" title="2">  <span class="fu">=</span> <span class="dt">Plus</span> <span class="fu">|</span> <span class="dt">Minus</span> <span class="fu">|</span> <span class="dt">Times</span></a></code></pre></div>
<p>and use them to extend the source language:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb32-2" title="2">  <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="fu">|</span> <span class="dt">Prim2</span> <span class="dt">Prim2</span>  (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a) a</a></code></pre></div>
<p>So, for example, <code>2 + 3</code> would be parsed as:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">Prim2</span> <span class="dt">Plus</span> (<span class="dt">Number</span> <span class="dv">2</span> ()) (<span class="dt">Number</span> <span class="dv">3</span> ()) ()</a></code></pre></div>
<h3 id="types-assembly-1">Types: Assembly</h3>
<p>Need to add X86 instructions for primitive arithmetic:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">data</span> <span class="dt">Instruction</span></a>
<a class="sourceLine" id="cb34-2" title="2">  <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb34-3" title="3">  <span class="fu">|</span> <span class="dt">IAdd</span> <span class="dt">Arg</span> <span class="dt">Arg</span></a>
<a class="sourceLine" id="cb34-4" title="4">  <span class="fu">|</span> <span class="dt">ISub</span> <span class="dt">Arg</span> <span class="dt">Arg</span></a>
<a class="sourceLine" id="cb34-5" title="5">  <span class="fu">|</span> <span class="dt">IMul</span> <span class="dt">Arg</span> <span class="dt">Arg</span></a></code></pre></div>
<h3 id="types-anf">Types: ANF</h3>
<p>We <em>can</em> define a separate type for ANF (try it!)</p>
<p>… but …</p>
<p><em>super tedious</em> as it requires duplicating a bunch of code.</p>
<p>Instead, lets write a <em>function</em> that describes <strong>immediate expressions</strong></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="ot">isImm ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb35-2" title="2">isImm (<span class="dt">Number</span> _ _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb35-3" title="3">isImm (<span class="dt">Var</span>    _ _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb35-4" title="4">isImm _            <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>We can now think of <strong>immediate</strong> expressions as:</p>
<blockquote>
<p>The <em>subset</em> of <code>Expr</code> <em>such that</em> <code>isImm</code> returns <code>True</code></p>
</blockquote>
<h3 id="quiz-4">QUIZ</h3>
<p>Similarly, lets write a function that describes <strong>ANF</strong> expressions</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="ot">isAnf ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb36-2" title="2">isAnf (<span class="dt">Number</span>  _     _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb36-3" title="3">isAnf (<span class="dt">Var</span>     _     _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb36-4" title="4">isAnf (<span class="dt">Prim2</span> _ e1 e2 _) <span class="fu">=</span> _1</a>
<a class="sourceLine" id="cb36-5" title="5">isAnf (<span class="dt">If</span> e1 e2 e3   _) <span class="fu">=</span> _2</a>
<a class="sourceLine" id="cb36-6" title="6">isAnf (<span class="dt">Let</span> x e1 e2   _) <span class="fu">=</span> _3</a></code></pre></div>
<p>What should we fill in for <code>_1</code>?</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="co">{- A -}</span> isAnf e1</a>
<a class="sourceLine" id="cb37-2" title="2"><span class="co">{- B -}</span> isAnf e2</a>
<a class="sourceLine" id="cb37-3" title="3"><span class="co">{- C -}</span> isAnf e1 <span class="fu">&amp;&amp;</span> isAnf e2</a>
<a class="sourceLine" id="cb37-4" title="4"><span class="co">{- D -}</span> isImm e1 <span class="fu">&amp;&amp;</span> isImm e2</a>
<a class="sourceLine" id="cb37-5" title="5"><span class="co">{- E -}</span> isImm e2</a></code></pre></div>
<h3 id="quiz-5">QUIZ</h3>
<p>Similarly, lets write a function that describes <strong>ANF</strong> expressions</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="ot">isAnf ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb38-2" title="2">isAnf (<span class="dt">Number</span>  _     _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb38-3" title="3">isAnf (<span class="dt">Var</span>     _     _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb38-4" title="4">isAnf (<span class="dt">Prim1</span> _ e1 _)    <span class="fu">=</span> isAnf e1 </a>
<a class="sourceLine" id="cb38-5" title="5">isAnf (<span class="dt">Prim2</span> _ e1 e2 _) <span class="fu">=</span> isImm e1 <span class="fu">&amp;&amp;</span> isImm e2 </a>
<a class="sourceLine" id="cb38-6" title="6">isAnf (<span class="dt">If</span> e1 e2 e3   _) <span class="fu">=</span> isANF e1 <span class="fu">&amp;&amp;</span> isANF e2 <span class="fu">&amp;&amp;</span> isANF e3</a>
<a class="sourceLine" id="cb38-7" title="7">isAnf (<span class="dt">Let</span> x e1 e2   _) <span class="fu">=</span> isANF e1 <span class="fu">&amp;&amp;</span> isANF e2 </a></code></pre></div>
<p>What should we fill in for <code>_2</code>?</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="co">{- A -}</span> isAnf e1      <span class="co">-- &lt;&lt;&lt;&lt;</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="co">{- B -}</span> isImm e1      <span class="co">-- &lt;&lt;&lt;&lt;</span></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="co">{- C -}</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="co">{- D -}</span> <span class="dt">False</span></a></code></pre></div>
<p>We can now think of <strong>ANF</strong> expressions as:</p>
<blockquote>
<p>The <em>subset</em> of <code>Expr</code> <em>such that</em> <code>isAnf</code> returns <code>True</code></p>
</blockquote>
<p>Use the above function to <strong>test</strong> our ANF conversion.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="ot">immArg ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ImmExpr</span> <span class="ot">-&gt;</span> <span class="dt">Arg</span></a>
<a class="sourceLine" id="cb40-2" title="2">immArg env (<span class="dt">Number</span> n _) <span class="fu">=</span> <span class="dt">Const</span> n</a>
<a class="sourceLine" id="cb40-3" title="3">immArg env (<span class="dt">Id</span> x _)     <span class="fu">=</span> <span class="dt">RegOffset</span> <span class="dt">EBP</span> (lookupEnv env x)</a>
<a class="sourceLine" id="cb40-4" title="4"></a>
<a class="sourceLine" id="cb40-5" title="5"><span class="ot">compileImm ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ImmExpr</span> <span class="dt">Tag</span> <span class="ot">-&gt;</span> [<span class="dt">Instruction</span>]</a>
<a class="sourceLine" id="cb40-6" title="6">compileImm env v  <span class="fu">=</span> [<span class="dt">IMov</span> (<span class="dt">Reg</span> <span class="dt">EAX</span>) (immArg env v) ]</a>
<a class="sourceLine" id="cb40-7" title="7"></a>
<a class="sourceLine" id="cb40-8" title="8"><span class="ot">compile ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">AnfExpr</span> <span class="dt">Tag</span> <span class="ot">-&gt;</span> [<span class="dt">Instruction</span>]</a>
<a class="sourceLine" id="cb40-9" title="9">compile env v<span class="fu">@</span>(<span class="dt">Number</span> {})  <span class="fu">=</span> compileImm env v</a>
<a class="sourceLine" id="cb40-10" title="10">compile env v<span class="fu">@</span>(<span class="dt">Id</span> _ _)     <span class="fu">=</span> compileImm env v </a>
<a class="sourceLine" id="cb40-11" title="11">compile env (<span class="dt">Prim1</span> op e)   <span class="fu">=</span> compile env e</a>
<a class="sourceLine" id="cb40-12" title="12">                          <span class="fu">++</span> [ (prim1Asm op (<span class="dt">Reg</span> <span class="dt">EAX</span>) (<span class="dt">Const</span> <span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb40-13" title="13">compile env (<span class="dt">Prim2</span> op v1 v2) <span class="fu">=</span> [ compileImm env v1 </a>
<a class="sourceLine" id="cb40-14" title="14">                               , prim2asm o (<span class="dt">Reg</span> <span class="dt">EAX</span>) (immArg env v2) </a>
<a class="sourceLine" id="cb40-15" title="15">                               ]</a>
<a class="sourceLine" id="cb40-16" title="16"></a>
<a class="sourceLine" id="cb40-17" title="17">prim2Asm <span class="dt">Add2</span> <span class="fu">=</span> <span class="dt">IAdd</span></a>
<a class="sourceLine" id="cb40-18" title="18">prim2Asm <span class="dt">Sub2</span> <span class="fu">=</span> <span class="dt">ISub</span></a>
<a class="sourceLine" id="cb40-19" title="19">prim2Asm <span class="dt">Mul2</span> <span class="fu">=</span> <span class="dt">IMul</span></a>
<a class="sourceLine" id="cb40-20" title="20"></a>
<a class="sourceLine" id="cb40-21" title="21">prim1Asm <span class="dt">Add1</span> <span class="fu">=</span> <span class="dt">IAdd</span></a>
<a class="sourceLine" id="cb40-22" title="22">prim1Asm <span class="dt">Sub1</span> <span class="fu">=</span> <span class="dt">ISub</span></a>
<a class="sourceLine" id="cb40-23" title="23"></a>
<a class="sourceLine" id="cb40-24" title="24"></a>
<a class="sourceLine" id="cb40-25" title="25"><span class="ot">anf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">AnfExpr</span> a)</a>
<a class="sourceLine" id="cb40-26" title="26">anf i p<span class="fu">@</span>(<span class="dt">Number</span> {}) <span class="fu">=</span> (i, p)</a>
<a class="sourceLine" id="cb40-27" title="27">anf i v<span class="fu">@</span>(<span class="dt">Id</span> {})     <span class="fu">=</span> (i, v)</a>
<a class="sourceLine" id="cb40-28" title="28">anf i (<span class="dt">Prim1</span> o e)   <span class="fu">=</span> (i', <span class="dt">Prim1</span> o e') </a>
<a class="sourceLine" id="cb40-29" title="29">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb40-30" title="30">    (i', e')        <span class="fu">=</span> anf i e</a>
<a class="sourceLine" id="cb40-31" title="31"></a>
<a class="sourceLine" id="cb40-32" title="32">anf i (<span class="dt">Prim2</span> o e1 e2) <span class="fu">=</span> (i2, mkLet (bs1 <span class="fu">++</span> bs2) (<span class="dt">Prim2</span> o v1 v2))</a>
<a class="sourceLine" id="cb40-33" title="33">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-34" title="34">     (i1, (bs1, v1))  <span class="fu">=</span> imm i  e1</a>
<a class="sourceLine" id="cb40-35" title="35">     (i2, (bs2, v2))  <span class="fu">=</span> imm i1 e2</a>
<a class="sourceLine" id="cb40-36" title="36"></a>
<a class="sourceLine" id="cb40-37" title="37">anf i (<span class="dt">Let</span> x  e1 e2)  <span class="fu">=</span> (i2, <span class="dt">Let</span> x e1' e2')</a>
<a class="sourceLine" id="cb40-38" title="38">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb40-39" title="39">     (i1, e1')        <span class="fu">=</span> anf i e1</a>
<a class="sourceLine" id="cb40-40" title="40">     (i2, e2')        <span class="fu">=</span> anf i1 e2</a>
<a class="sourceLine" id="cb40-41" title="41"></a>
<a class="sourceLine" id="cb40-42" title="42">anf i (<span class="dt">If</span>  e1 e2 e3)  <span class="fu">=</span> (i3, <span class="dt">If</span> e1' e2' e3')</a>
<a class="sourceLine" id="cb40-43" title="43">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb40-44" title="44">     (i1, e1')        <span class="fu">=</span> anf i e1</a>
<a class="sourceLine" id="cb40-45" title="45">     (i2, e2')        <span class="fu">=</span> anf i1 e2</a>
<a class="sourceLine" id="cb40-46" title="46">     (i3, e3')        <span class="fu">=</span> anf i2 e3</a>
<a class="sourceLine" id="cb40-47" title="47"></a>
<a class="sourceLine" id="cb40-48" title="48"><span class="ot">imm ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> (<span class="dt">Int</span>, ([(<span class="dt">Id</span> , <span class="dt">AnfExpr</span> a)] , <span class="dt">ImmExpr</span> a))</a>
<a class="sourceLine" id="cb40-49" title="49">imm i e<span class="fu">@</span>(<span class="dt">Number</span> {}) <span class="fu">=</span> (i, ([], e))</a>
<a class="sourceLine" id="cb40-50" title="50">imm i e<span class="fu">@</span>(<span class="dt">Id</span> {})     <span class="fu">=</span> (i, ([], e))</a>
<a class="sourceLine" id="cb40-51" title="51">imm i e<span class="fu">@</span>(<span class="dt">Prim1</span> {})  <span class="fu">=</span> immExp i e</a>
<a class="sourceLine" id="cb40-52" title="52">imm i e<span class="fu">@</span>(<span class="dt">If</span> {})     <span class="fu">=</span> immExp i e</a>
<a class="sourceLine" id="cb40-53" title="53">imm i e<span class="fu">@</span>(<span class="dt">Let</span> {})    <span class="fu">=</span> immExp i e</a>
<a class="sourceLine" id="cb40-54" title="54"></a>
<a class="sourceLine" id="cb40-55" title="55">imm i (<span class="dt">Prim2</span> o e1 e2) <span class="fu">=</span> (i2<span class="fu">+</span><span class="dv">1</span>, ((v, <span class="dt">Prim2</span> o v1 v2) <span class="fu">:</span> bs2 <span class="fu">++</span> bs1, <span class="dt">Id</span> v))</a>
<a class="sourceLine" id="cb40-56" title="56">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-57" title="57">    (i1, (bs1, v1)) <span class="fu">=</span> imm i e1</a>
<a class="sourceLine" id="cb40-58" title="58">    (i2, (bs2, v2)) <span class="fu">=</span> imm i1 e2</a>
<a class="sourceLine" id="cb40-59" title="59">    v               <span class="fu">=</span> mkTmpVar i2</a>
<a class="sourceLine" id="cb40-60" title="60"></a>
<a class="sourceLine" id="cb40-61" title="61">mkTmpVar i <span class="fu">=</span> <span class="st">&quot;tmp&quot;</span> <span class="fu">++</span> <span class="fu">show</span> i</a>
<a class="sourceLine" id="cb40-62" title="62"></a>
<a class="sourceLine" id="cb40-63" title="63"><span class="ot">mkLet ::</span> [(<span class="dt">Id</span> , <span class="dt">AnfExpr</span> a)] <span class="ot">-&gt;</span> <span class="dt">AnfExpr</span> a <span class="ot">-&gt;</span> <span class="dt">AnfExpr</span> a</a>
<a class="sourceLine" id="cb40-64" title="64">mkLet []              e <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb40-65" title="65">mkLet ((x1, e1) <span class="fu">:</span> bs) e <span class="fu">=</span> <span class="dt">Let</span> x1 e1 (mkLet bs e)</a>
<a class="sourceLine" id="cb40-66" title="66"></a>
<a class="sourceLine" id="cb40-67" title="67">immExp i e  <span class="fu">=</span> (i' <span class="fu">+</span> <span class="dv">1</span>, ([(v, e')], v))</a>
<a class="sourceLine" id="cb40-68" title="68">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-69" title="69">    (i',e') <span class="fu">=</span> anf e</a>
<a class="sourceLine" id="cb40-70" title="70">    v       <span class="fu">=</span> mkTmpVar i'</a></code></pre></div>
<h3 id="types-strategy">Types &amp; Strategy</h3>
<p>Writing the type aliases:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1"><span class="kw">type</span> <span class="dt">BareE</span>   <span class="fu">=</span> <span class="dt">Expr</span> ()</a>
<a class="sourceLine" id="cb41-2" title="2"><span class="kw">type</span> <span class="dt">AnfE</span>    <span class="fu">=</span> <span class="dt">Expr</span> ()  <span class="co">-- such that isAnf is True</span></a>
<a class="sourceLine" id="cb41-3" title="3"><span class="kw">type</span> <span class="dt">AnfTagE</span> <span class="fu">=</span> <span class="dt">Expr</span> <span class="dt">Tag</span> <span class="co">-- such that isAnf is True</span></a>
<a class="sourceLine" id="cb41-4" title="4"><span class="kw">type</span> <span class="dt">ImmTagE</span> <span class="fu">=</span> <span class="dt">Expr</span> <span class="dt">Tag</span> <span class="co">-- such that isImm is True</span></a></code></pre></div>
<p>we get the overall pipeline:</p>
<figure>
<img src="../static/img/compiler-pipeline-anf-types.png" alt="Compiler Pipeline with ANF: Types" /><figcaption>Compiler Pipeline with ANF: Types</figcaption>
</figure>
<h3 id="transforms-compiling-anftage-to-asm">Transforms: Compiling <code>AnfTagE</code> to <code>Asm</code></h3>
<figure>
<img src="../static/img/compiler-pipeline-anf-to-asm.png" alt="Compiler Pipeline: ANF to ASM" /><figcaption>Compiler Pipeline: ANF to ASM</figcaption>
</figure>
<p>The compilation from ANF is easy, lets recall our examples and strategy:</p>
<p>Strategy: Given <code>v1 + v2</code> (where <code>v1</code> and <code>v2</code> are <strong>immediate expressions</strong>)</p>
<ul>
<li>Move <code>v1</code> into <code>eax</code>,</li>
<li>Add <code>v2</code> to <code>eax</code>.</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">compile ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">TagE</span> <span class="ot">-&gt;</span> <span class="dt">Asm</span></a>
<a class="sourceLine" id="cb42-2" title="2">compile env (<span class="dt">Prim2</span> o v1 v2)</a>
<a class="sourceLine" id="cb42-3" title="3">  <span class="fu">=</span> [ <span class="dt">IMov</span>      (<span class="dt">Reg</span> <span class="dt">EAX</span>) (immArg env v1)</a>
<a class="sourceLine" id="cb42-4" title="4">    , (prim2 o) (<span class="dt">Reg</span> <span class="dt">EAX</span>) (immArg env v2)</a>
<a class="sourceLine" id="cb42-5" title="5">    ]</a></code></pre></div>
<p>where we have a helper to find the <code>Asm</code> variant of a <code>Prim2</code> operation</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="ot">prim2 ::</span> <span class="dt">Prim2</span> <span class="ot">-&gt;</span> <span class="dt">Arg</span> <span class="ot">-&gt;</span> <span class="dt">Arg</span> <span class="ot">-&gt;</span> <span class="dt">Instruction</span></a>
<a class="sourceLine" id="cb43-2" title="2">prim2 <span class="dt">Plus</span>  <span class="fu">=</span> <span class="dt">IAdd</span></a>
<a class="sourceLine" id="cb43-3" title="3">prim2 <span class="dt">Minus</span> <span class="fu">=</span> <span class="dt">ISub</span></a>
<a class="sourceLine" id="cb43-4" title="4">prim2 <span class="dt">Times</span> <span class="fu">=</span> <span class="dt">IMul</span></a></code></pre></div>
<p>and another to convert an <em>immediate expression</em> to an x86 argument:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="ot">immArg ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ImmTag</span> <span class="ot">-&gt;</span> <span class="dt">Arg</span></a>
<a class="sourceLine" id="cb44-2" title="2">immArg _   (<span class="dt">Number</span> n _) <span class="fu">=</span> <span class="dt">Const</span> n</a>
<a class="sourceLine" id="cb44-3" title="3">immArg env (<span class="dt">Var</span>    x _) <span class="fu">=</span> <span class="dt">RegOffset</span> <span class="dt">ESP</span> i</a>
<a class="sourceLine" id="cb44-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-5" title="5">    i                   <span class="fu">=</span> fromMaybe err (<span class="fu">lookup</span> x env)</a>
<a class="sourceLine" id="cb44-6" title="6">    err                 <span class="fu">=</span> <span class="fu">error</span> (printf <span class="st">&quot;Error: Variable '%s' is unbound&quot;</span> x)</a></code></pre></div>
<h3 id="quiz-6">QUIZ</h3>
<p>Which of the below are in ANF ?</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="co">{- 1 -}</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="co">{- 2 -}</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">12</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb45-4" title="4">          x <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb45-5" title="5"></a>
<a class="sourceLine" id="cb45-6" title="6"><span class="co">{- 3 -}</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb45-7" title="7">          , y <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb45-8" title="8">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb45-9" title="9">          x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb45-10" title="10"></a>
<a class="sourceLine" id="cb45-11" title="11"><span class="co">{- 4 -}</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb45-12" title="12">          , y <span class="fu">=</span> <span class="dv">18</span></a>
<a class="sourceLine" id="cb45-13" title="13">          , t <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb45-14" title="14">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb45-15" title="15">          <span class="kw">if</span> t<span class="fu">:</span> <span class="dv">7</span> <span class="kw">else</span><span class="fu">:</span> <span class="dv">9</span></a></code></pre></div>
<ul>
<li><p><strong>A.</strong> <code>1, 2, 3, 4</code></p></li>
<li><p><strong>B.</strong> <code>1, 2, 3</code></p></li>
<li><p><strong>C.</strong> <code>2, 3, 4</code></p></li>
<li><p><strong>D.</strong> <code>1, 2</code></p></li>
<li><p><strong>E.</strong> <code>2, 3</code></p></li>
</ul>
<h3 id="transforms-compiling-bare-to-anf">Transforms: Compiling <code>Bare</code> to <code>Anf</code></h3>
<p>Next lets focus on <strong>A-Normalization</strong> i.e. transforming expressions into ANF</p>
<figure>
<img src="../static/img/compiler-pipeline-bare-to-anf.png" alt="Compiler Pipeline: Bare to ANF" /><figcaption>Compiler Pipeline: Bare to ANF</figcaption>
</figure>
<h3 id="a-normalization">A-Normalization</h3>
<p>We can fill in the base cases easily</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1">anf (<span class="dt">Number</span> n)      <span class="fu">=</span> <span class="dt">Number</span> n</a>
<a class="sourceLine" id="cb46-2" title="2">anf (<span class="dt">Var</span> x)         <span class="fu">=</span> <span class="dt">Var</span> x</a></code></pre></div>
<p>Interesting cases are the binary operations</p>
<h4 id="example-anf-1">Example: Anf-1</h4>
<p>Left operand is not immediate</p>
<figure>
<img src="../static/img/anf-1.png" alt="Example: ANF 1" /><figcaption>Example: ANF 1</figcaption>
</figure>
<p><strong>Key Idea: Helper Function</strong></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="ot">imm ::</span> <span class="dt">BareE</span> <span class="ot">-&gt;</span> ([(<span class="dt">Id</span>, <span class="dt">AnfE</span>)], <span class="dt">ImmE</span>)</a></code></pre></div>
<p><code>imm e</code> returns <code>([(t1, a1),...,(tn, an)], v)</code> where</p>
<ul>
<li><code>ti, ai</code> are new temporary variables bound to ANF exprs,</li>
<li><code>v</code> is an <strong>immediate value</strong> (either a constant or variable)</li>
</ul>
<p>Such that <code>e</code> is <em>equivalent to</em></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">let</span> t1 <span class="fu">=</span> a1</a>
<a class="sourceLine" id="cb48-2" title="2">  , <span class="fu">...</span></a>
<a class="sourceLine" id="cb48-3" title="3">  , tn <span class="fu">=</span> an</a>
<a class="sourceLine" id="cb48-4" title="4"><span class="kw">in</span></a>
<a class="sourceLine" id="cb48-5" title="5">   v</a></code></pre></div>
<p>Lets look at some more examples.</p>
<h4 id="example-anf-2">Example: Anf-2</h4>
<p>Left operand is not internally immediate</p>
<figure>
<img src="../static/img/anf-2.png" alt="Example: ANF 2" /><figcaption>Example: ANF 2</figcaption>
</figure>
<h4 id="example-anf-3">Example: Anf-3</h4>
<p>Both operands are not immediate</p>
<figure>
<img src="../static/img/anf-3.png" alt="Example: ANF 3" /><figcaption>Example: ANF 3</figcaption>
</figure>
<h3 id="anf-general-strategy">ANF: General Strategy</h3>
<figure>
<img src="../static/img/anf-strategy.png" alt="ANF Strategy" /><figcaption>ANF Strategy</figcaption>
</figure>
<ol type="1">
<li><strong>Invoke</strong> <code>imm</code> on both the operands</li>
<li><strong>Concat</strong> the <code>let</code> bindings</li>
<li><strong>Apply</strong> the binop to the immediate values</li>
</ol>
<h3 id="anf-implementation">ANF: Implementation</h3>
<p>Lets implement the above strategy</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1">anf (<span class="dt">Prim2</span> o e1 e2) <span class="fu">=</span> lets (b1s <span class="fu">++</span> b2s)</a>
<a class="sourceLine" id="cb49-2" title="2">                        (<span class="dt">Prim2</span> o (<span class="dt">Var</span> v1) (<span class="dt">Var</span> v2))</a>
<a class="sourceLine" id="cb49-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-4" title="4">    (b1s, v1)       <span class="fu">=</span> imm e1</a>
<a class="sourceLine" id="cb49-5" title="5">    (b2s, v2)       <span class="fu">=</span> imm e2</a>
<a class="sourceLine" id="cb49-6" title="6"></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="ot">lets ::</span> [(<span class="dt">Id</span>, <span class="dt">AnfE</span>)] <span class="ot">-&gt;</span> <span class="dt">AnfE</span> <span class="ot">-&gt;</span> <span class="dt">AnfE</span></a>
<a class="sourceLine" id="cb49-8" title="8">lets []         e' <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb49-9" title="9">lets ((x,e)<span class="fu">:</span>bs) e' <span class="fu">=</span> <span class="dt">Let</span> x e (lets bs e')</a></code></pre></div>
<p>Intuitively, <code>lets</code> <em>stitches</em> together a bunch of definitions as follows:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1">lets [(x1, e1), (x2, e2), (x3, e3)] e</a>
<a class="sourceLine" id="cb50-2" title="2">  <span class="fu">===&gt;</span> <span class="dt">Let</span> x1 e1 (<span class="dt">Let</span> x2 e2 (<span class="dt">Let</span> x3 e3 e))</a></code></pre></div>
<p>For <code>Let</code> just make sure we recursively <code>anf</code> the sub-expressions.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1">anf (<span class="dt">Let</span> x e1 e2)   <span class="fu">=</span> <span class="dt">Let</span> x e1' e2'</a>
<a class="sourceLine" id="cb51-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-3" title="3">    e1'             <span class="fu">=</span> anf e1</a>
<a class="sourceLine" id="cb51-4" title="4">    e2'             <span class="fu">=</span> anf e2</a></code></pre></div>
<p>Same principle applies to <code>If</code></p>
<ul>
<li>use <code>anf</code> to recursively transform the branches.</li>
</ul>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1">anf (<span class="dt">If</span> e1 e2 e3) <span class="fu">=</span> <span class="dt">If</span> e1' e2' e3'  </a>
<a class="sourceLine" id="cb52-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb52-3" title="3">    e1'           <span class="fu">=</span> anf e1</a>
<a class="sourceLine" id="cb52-4" title="4">    e2'           <span class="fu">=</span> anf e2</a>
<a class="sourceLine" id="cb52-5" title="5">    e3'           <span class="fu">=</span> anf e3</a></code></pre></div>
<h3 id="anf-making-arguments-immediate-via-imm">ANF: Making Arguments Immediate via <code>imm</code></h3>
<p>The workhorse is the function</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="ot">imm ::</span> <span class="dt">BareE</span> <span class="ot">-&gt;</span> ([(<span class="dt">Id</span>, <span class="dt">AnfE</span>)], <span class="dt">ImmE</span>)</a></code></pre></div>
<p>which creates temporary variables to crunch an arbitrary <code>Bare</code> into an <em>immediate</em> value.</p>
<p>No need to create an variables if the expression is <em>already</em> immediate:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1">imm (<span class="dt">Number</span> n l) <span class="fu">=</span> ( [], <span class="dt">Number</span> n l )</a>
<a class="sourceLine" id="cb54-2" title="2">imm (<span class="dt">Id</span>     x l) <span class="fu">=</span> ( [], <span class="dt">Id</span>     x l )</a></code></pre></div>
<p>The tricky case is when the expression has a primop:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" title="1">imm (<span class="dt">Prim2</span> o e1 e2) <span class="fu">=</span> ( b1s <span class="fu">++</span> b2s <span class="fu">++</span> [(t,  <span class="dt">Prim2</span> o v1 v2)]</a>
<a class="sourceLine" id="cb55-2" title="2">                      , <span class="dt">Id</span> t  )</a>
<a class="sourceLine" id="cb55-3" title="3">  t                 <span class="fu">=</span> makeFreshVar ()</a>
<a class="sourceLine" id="cb55-4" title="4">  (b1s, v1)         <span class="fu">=</span> imm e1</a>
<a class="sourceLine" id="cb55-5" title="5">  (b2s, v2)         <span class="fu">=</span> imm e2  </a></code></pre></div>
<p>Oh, what shall we do when:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1">imm (<span class="dt">If</span> e1 e2 e3)   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb56-2" title="2">imm (<span class="dt">Let</span> x e1 e2)   <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>Lets look at an example for inspiration.</p>
<figure>
<img src="../static/img/anf-4.png" alt="Example: ANF 4" /><figcaption>Example: ANF 4</figcaption>
</figure>
<p>That is, simply</p>
<ul>
<li><code>anf</code> the relevant expressions,</li>
<li>bind them to a fresh variable.</li>
</ul>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" title="1">imm e<span class="fu">@</span>(<span class="dt">If</span> _ _ _) <span class="fu">=</span> immExp e</a>
<a class="sourceLine" id="cb57-2" title="2">imm e<span class="fu">@</span>(<span class="dt">If</span> _ _ _) <span class="fu">=</span> immExp e</a>
<a class="sourceLine" id="cb57-3" title="3"></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="ot">immExp ::</span> <span class="dt">AnfE</span> <span class="ot">-&gt;</span> ([(<span class="dt">Id</span>, <span class="dt">AnfE</span>)], <span class="dt">ImmE</span>)</a>
<a class="sourceLine" id="cb57-5" title="5">immExp e <span class="fu">=</span> ([(t, e')], t)</a>
<a class="sourceLine" id="cb57-6" title="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb57-7" title="7">    e'   <span class="fu">=</span> anf e</a>
<a class="sourceLine" id="cb57-8" title="8">    t    <span class="fu">=</span> makeFreshVar ()</a></code></pre></div>
<h3 id="one-last-thing-whats-up-with-makefreshvar">One last thing: Whats up with <code>makeFreshVar</code> ?</h3>
<p>Wait a minute, what is this magic <strong>FRESH</strong> ?</p>
<p>How can we create <strong>distinct</strong> names out of thin air?</p>
<p>What’s that? Global variables? Increment a counter?</p>
<figure>
<img src="../static/img/dr-evil.jpg" alt="Get thee behind me Satan!" /><figcaption>Get thee behind me Satan!</figcaption>
</figure>
<p>We will use a counter, but will have to <strong>pass its value around</strong></p>
<blockquote>
<p>Just like <code>doTag</code></p>
</blockquote>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" title="1"><span class="ot">anf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BareE</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">AnfE</span>)</a>
<a class="sourceLine" id="cb58-2" title="2"></a>
<a class="sourceLine" id="cb58-3" title="3">anf i (<span class="dt">Number</span> n l)      <span class="fu">=</span> (i, <span class="dt">Number</span> n l)</a>
<a class="sourceLine" id="cb58-4" title="4"></a>
<a class="sourceLine" id="cb58-5" title="5">anf i (<span class="dt">Id</span>     x l)      <span class="fu">=</span> (i, <span class="dt">Id</span>     x l)</a>
<a class="sourceLine" id="cb58-6" title="6"></a>
<a class="sourceLine" id="cb58-7" title="7">anf i (<span class="dt">Let</span> x e b l)     <span class="fu">=</span> (i'', <span class="dt">Let</span> x e' b' l)</a>
<a class="sourceLine" id="cb58-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-9" title="9">    (i',  e')           <span class="fu">=</span> anf i e</a>
<a class="sourceLine" id="cb58-10" title="10">    (i'', b')           <span class="fu">=</span> anf i' b</a>
<a class="sourceLine" id="cb58-11" title="11"></a>
<a class="sourceLine" id="cb58-12" title="12">anf i (<span class="dt">Prim2</span> o e1 e2 l) <span class="fu">=</span> (i'', lets (b1s <span class="fu">++</span> b2s) (<span class="dt">Prim2</span> o e1' e2' l))</a>
<a class="sourceLine" id="cb58-13" title="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-14" title="14">    (i' , b1s, e1')     <span class="fu">=</span> imm i  e1</a>
<a class="sourceLine" id="cb58-15" title="15">    (i'', b2s, e2')     <span class="fu">=</span> imm i' e2</a>
<a class="sourceLine" id="cb58-16" title="16"></a>
<a class="sourceLine" id="cb58-17" title="17">anf i (<span class="dt">If</span> c e1 e2 l)    <span class="fu">=</span> (i''', lets bs  (<span class="dt">If</span> c' e1' e2' l))</a>
<a class="sourceLine" id="cb58-18" title="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-19" title="19">    (i'  , bs, c')      <span class="fu">=</span> imm i   c</a>
<a class="sourceLine" id="cb58-20" title="20">    (i'' ,     e1')     <span class="fu">=</span> anf i'  e1</a>
<a class="sourceLine" id="cb58-21" title="21">    (i''',     e2')     <span class="fu">=</span> anf i'' e2</a></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" title="1"><span class="ot">imm ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AnfE</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, [(<span class="dt">Id</span>, <span class="dt">AnfE</span>)], <span class="dt">ImmE</span>)</a>
<a class="sourceLine" id="cb59-2" title="2"></a>
<a class="sourceLine" id="cb59-3" title="3">imm i (<span class="dt">Number</span> n l)        <span class="fu">=</span> (i  , [], <span class="dt">Number</span> n l)</a>
<a class="sourceLine" id="cb59-4" title="4"></a>
<a class="sourceLine" id="cb59-5" title="5">imm i (<span class="dt">Var</span> x l)           <span class="fu">=</span> (i  , [], <span class="dt">Var</span> x l)</a>
<a class="sourceLine" id="cb59-6" title="6"></a>
<a class="sourceLine" id="cb59-7" title="7">imm i (<span class="dt">Prim2</span> o e1 e2 l) <span class="fu">=</span> (i''', bs, <span class="dt">Var</span> v l)</a>
<a class="sourceLine" id="cb59-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-9" title="9">    (i'  , b1s, v1)     <span class="fu">=</span> imm i  e1</a>
<a class="sourceLine" id="cb59-10" title="10">    (i'' , b2s, v2)     <span class="fu">=</span> imm i' e2</a>
<a class="sourceLine" id="cb59-11" title="11">    (i''', v)           <span class="fu">=</span> fresh i''</a>
<a class="sourceLine" id="cb59-12" title="12">    bs                  <span class="fu">=</span> b1s <span class="fu">++</span> b2s <span class="fu">++</span> [(v, <span class="dt">Prim2</span> o v1 v2 l)]</a>
<a class="sourceLine" id="cb59-13" title="13"></a>
<a class="sourceLine" id="cb59-14" title="14">imm i e<span class="fu">@</span>(<span class="dt">If</span> _ _ _  l)   <span class="fu">=</span> immExp i e</a>
<a class="sourceLine" id="cb59-15" title="15"></a>
<a class="sourceLine" id="cb59-16" title="16">imm i e<span class="fu">@</span>(<span class="dt">Let</span> _ _ _ l)   <span class="fu">=</span> immExp i e</a>
<a class="sourceLine" id="cb59-17" title="17"></a>
<a class="sourceLine" id="cb59-18" title="18"><span class="ot">immExp ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BareE</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, [(<span class="dt">Id</span>, <span class="dt">AnfE</span>)], <span class="dt">ImmE</span>)</a>
<a class="sourceLine" id="cb59-19" title="19">immExp i e l  <span class="fu">=</span> (i'', bs, <span class="dt">Var</span> v ())</a>
<a class="sourceLine" id="cb59-20" title="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-21" title="21">    (i' , e') <span class="fu">=</span> anf i e</a>
<a class="sourceLine" id="cb59-22" title="22">    (i'', v)  <span class="fu">=</span> fresh i'</a>
<a class="sourceLine" id="cb59-23" title="23">    bs        <span class="fu">=</span> [(v, e')]</a></code></pre></div>
<p>where now, the <code>fresh</code> function returns a <em>new counter</em> and a variable</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" title="1"><span class="ot">fresh ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Id</span>)</a>
<a class="sourceLine" id="cb60-2" title="2">fresh n <span class="fu">=</span> (n<span class="fu">+</span><span class="dv">1</span>, <span class="st">&quot;t&quot;</span> <span class="fu">++</span> <span class="fu">show</span> n)</a></code></pre></div>
<p><strong>Note</strong> this is super clunky. There <em>is</em> a really slick way to write the above code without the clutter of the <code>i</code> but thats too much of a digression, <a href="https://cseweb.ucsd.edu/classes/wi12/cse230-a/lectures/monads.html">but feel free to look it up yourself</a></p>
<h2 id="recap-and-summary">Recap and Summary</h2>
<p>Just created <code>Boa</code> with</p>
<ul>
<li>Branches (<code>if</code>-expressions)</li>
<li>Binary Operators (<code>+</code>, <code>-</code>, etc.)</li>
</ul>
<p>In the process of doing so, we will learned about</p>
<ul>
<li><strong>Intermediate Forms</strong></li>
<li><strong>Normalization</strong></li>
</ul>
<p>Specifically,</p>
<figure>
<img src="../static/img/compiler-pipeline-anf-types.png" alt="Compiler Pipeline with ANF" /><figcaption>Compiler Pipeline with ANF</figcaption>
</figure>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
